<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <link rel="stylesheet" href="styles.css"/>
  <title>Difficult Videogames</title>
  <script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
</head>
<body>

<!-- ðŸ”´ â€œYou Diedâ€ style intro overlay -->
  <div id="intro-overlay" role="dialog" aria-modal="true" aria-label="Page title">
    <div class="intro-inner">
      <h1 class="intro-title">Difficult Videogames</h1>
      <p class="intro-sub">click anywhere to continue</p>
    </div>
  </div>


  <section id="section1" class="panel"><h2>This is Section 1</h2></section>
  <section id="section2" class="panel"><h2>This is Section 2</h2></section>
  <section id="section3" class="panel"><h2>This is Section 3</h2></section>
  <section id="section4" class="panel"><h2>This is Section 4</h2></section>
  <section id="section5" class="panel"><h2>This is Section 5</h2></section>

  <script>


// Intro overlay: show on load, dismiss on click or Esc
    $(function () {
      const $overlay = $("#intro-overlay");

      // start entrance animation after a tiny tick (ensures CSS transition)
      requestAnimationFrame(() => $overlay.addClass("in"));

      function dismissOverlay() {
        $overlay.addClass("out");
        // remove from DOM after fade to prevent accidental captures
        setTimeout(() => $overlay.remove(), 500);
      }

      $overlay.on("click", dismissOverlay);
      $(window).on("keydown", (e) => {
        if (e.key === "Escape" || e.key === "Enter" || e.key === " ") dismissOverlay();
      });
    });

    $(function () {
      const $win = $(window);
      const $root = $("html, body");
      const $sections = $(".panel");

      let tops = [];
      let index = 0;
      let animating = false;
      let wheelCooldown = false;

      function measure() {
        tops = $sections.map(function () {
          return Math.round($(this).offset().top);
        }).get();
      }

      function clamp(i) {
        return Math.max(0, Math.min(i, $sections.length - 1));
      }

      function scrollToIndex(i, duration = 500) {
        i = clamp(i);
        animating = true;
        wheelCooldown = true; // ignore wheel momentum during animation
        $root.stop(true).animate(
          { scrollTop: tops[i] },
          duration,
          "swing",
          function () {
            animating = false;
            index = i;
            // brief cooldown to swallow extra wheel deltas from touchpads
            setTimeout(() => (wheelCooldown = false), 120);
          }
        );
      }

      function nearestIndex(scrollTop) {
        let best = 0, bestDist = Infinity;
        for (let i = 0; i < tops.length; i++) {
          const d = Math.abs(tops[i] - scrollTop);
          if (d < bestDist) { bestDist = d; best = i; }
        }
        return best;
      }

      // Initial layout + snap to first
      measure();
      $root.scrollTop(tops[0]);

      // Wheel/trackpad
      // Use passive: false so we can preventDefault()
      window.addEventListener("wheel", function (ev) {
        if (animating || wheelCooldown) { ev.preventDefault(); return; }
        const dy = ev.deltaY || ev.wheelDeltaY || ev.wheelDelta || 0;
        if (dy === 0) return;

        ev.preventDefault(); // no partial scrolls
        let next = index + (dy > 0 ? 1 : -1);
        scrollToIndex(next);
      }, { passive: false });

      // Keyboard
      $(window).on("keydown", function (e) {
        if (animating) return;
        const nextKeys = ["ArrowDown", "PageDown", " "];
        const prevKeys = ["ArrowUp", "PageUp"];
        if (nextKeys.includes(e.key)) {
          e.preventDefault();
          scrollToIndex(index + 1);
        } else if (prevKeys.includes(e.key)) {
          e.preventDefault();
          scrollToIndex(index - 1);
        } else if (e.key === "Home") {
          e.preventDefault();
          scrollToIndex(0);
        } else if (e.key === "End") {
          e.preventDefault();
          scrollToIndex($sections.length - 1);
        }
      });

      // Touch (swipe)
      let touchStartY = null;
      window.addEventListener("touchstart", (e) => {
        if (animating) return;
        touchStartY = e.touches[0].clientY;
      }, { passive: true });

      window.addEventListener("touchend", (e) => {
        if (animating || touchStartY == null) return;
        const endY = e.changedTouches[0].clientY;
        const diff = touchStartY - endY;
        const threshold = 40;
        if (Math.abs(diff) > threshold) {
          scrollToIndex(index + (diff > 0 ? 1 : -1));
        }
        touchStartY = null;
      }, { passive: true });

      // Keep index aligned if user jumps (e.g., scroll bar click) or after resize
      let scrollDebounce;
      $(window).on("scroll", function () {
        if (animating) return;
        clearTimeout(scrollDebounce);
        scrollDebounce = setTimeout(() => {
          const st = Math.round($win.scrollTop());
          index = nearestIndex(st);
        }, 80);
      });

      let resizeDebounce;
      $(window).on("resize", function () {
        clearTimeout(resizeDebounce);
        resizeDebounce = setTimeout(() => {
          const currentId = $sections.eq(index).attr("id");
          measure();
          // restore alignment to the same section after layout change
          const i = Math.max(0, $sections.index($("#" + currentId)));
          $root.stop(true, true).scrollTop(tops[i]);
          index = i;
        }, 100);
      });
    });
  </script>
</body>
</html>
