<!DOCTYPE html>
<html lang="en">

<head>
     <meta charset="UTF-8" />
     <meta name="viewport" content="width=device-width,initial-scale=1.0" />
     <link rel="stylesheet" href="styles.css" />
     <title>Difficult Videogames</title>
     <script src="https://code.jquery.com/jquery-3.7.1.min.js"
          integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
</head>

<body>

     <!--“You Died” style intro overlay -->
     <div id="intro-overlay" role="dialog" aria-modal="true" aria-label="Page title">
          <div class="intro-inner">
               <h1 class="intro-title">Difficult Videogames (WIP)</h1>
               <p class="intro-sub">click anywhere to continue</p>
          </div>
     </div>

     <!--Left progress/navigation rail (7 notches now) -->
     <nav id="nav-rail" aria-label="Page progress">
          <div class="rail">
               <div class="rail-fill" aria-hidden="true"></div>

               <!-- 7 evenly spaced notches (prologue..epilogue) -->
               <div class="nav-item" style="top:0%" data-i="0">
                    <button class="notch" aria-label="Go to Prologue"></button>
                    <span class="label">Prologue</span>
               </div>
               <div class="nav-item" style="top:16.66%" data-i="1">
                    <button class="notch" aria-label="Go to Section 1"></button>
                    <span class="label">Act 1</span>
               </div>
               <div class="nav-item" style="top:33.33%" data-i="2">
                    <button class="notch" aria-label="Go to Section 2"></button>
                    <span class="label">Act 2</span>
               </div>
               <div class="nav-item" style="top:50%" data-i="3">
                    <button class="notch" aria-label="Go to Section 3"></button>
                    <span class="label">Act 3</span>
               </div>
               <div class="nav-item" style="top:66.66%" data-i="4">
                    <button class="notch" aria-label="Go to Section 4"></button>
                    <span class="label">Act 4</span>
               </div>
               <div class="nav-item" style="top:83.33%" data-i="5">
                    <button class="notch" aria-label="Go to Section 5"></button>
                    <span class="label">Act 5</span>
               </div>
               <div class="nav-item" style="top:100%" data-i="6">
                    <button class="notch" aria-label="Go to Epilogue"></button>
                    <span class="label">Epilogue</span>
               </div>
          </div>
     </nav>

     <!-- Sections -->
     <section id="prologue" class="panel">

          <article class="content">
               <h1 class="title">Prologue: Why We Love to Suffer (Digitally)</h1>
               <p class="tooltip"> Why We Love to Suffer (Digitally) </p>
               <p>From <em>Dark Souls</em> and <em>Sekiro</em> to <em>Cuphead</em> and <em>Getting Over It with Bennett
                         Foddy</em>, modern gaming has embraced a new breed of challenge—one that seems almost designed
                    to test the limits of our patience. These are games that punish mistakes, offer little mercy, and
                    proudly display your failures with every “You Died” screen. Yet despite the rage and frustration,
                    players flock to them, replaying boss fights hundreds of times and celebrating even the smallest
                    victories.</p>
               <p>Why do we voluntarily endure such torment—and even enjoy it? The answer lies not in masochism, but in
                    psychology. Difficult games offer something deeper than surface-level fun: they satisfy primal human
                    needs for mastery, growth, and meaning. They transform frustration into fulfillment, making players
                    feel alive in ways few other activities can.</p>
          </article>
     </section>

     <section id="section1" class="panel">
          <article class="content">
               <h1 class="title">Act 1: Flow in the Face of Frustration</h1>
               <p class="tooltip">Flow in the Face of Frustration</p>
               <p>At first glance, difficulty and enjoyment seem incompatible. How can failing repeatedly be fun?
                    Cognitive psychology provides the answer through Mihaly Csikszentmihalyi’s concept of
                    <strong>flow</strong>—a mental state of deep, focused immersion that occurs when the challenge of a
                    task perfectly matches the individual’s skill level.
               </p>
               <p>When games are too easy, we get bored. When they’re too hard, we feel anxious or helpless. But when a
                    game strikes that delicate balance—demanding constant focus while still feeling achievable—it
                    creates flow. Time fades away, and every small success feels electric. This is why players can spend
                    hours replaying the same section in <em>Elden Ring</em> or <em>Celeste</em>: the game continually
                    pushes them to learn, adapt, and refine their skills.</p>
               <p>Frustration becomes part of the pleasure because it gives meaning to success. When victory finally
                    arrives, it isn’t luck—it’s earned. The struggle is the story.</p>
          </article>
     </section>

     <section id="section2" class="panel">
          <article class="content">
               <h1 class="title">Act 2: Mastery and the Reward of Competence</h1>
               <p class="tooltip">Mastery and the Reward of Competence</p>
               <p>According to Self-Determination Theory (SDT), human motivation is powered by three intrinsic needs:
                    <strong>autonomy</strong>, <strong>relatedness</strong>, and <strong>competence</strong>. Difficult
                    games speak directly to competence.
               </p>
               <p>When you finally defeat a tough boss in <em>Dark Souls</em>, the game doesn’t just progress—it proves
                    something. Mastery produces a neurological reward: a burst of dopamine. Unlike the instant
                    gratification of easy games, this reward feels hard-earned, authentic, and lasting.</p>
               <p>Players often describe difficult games as <em>fair</em>. Failure is yours to own—and so is victory.
                    That clarity fuels a powerful loop of fail → learn → improve → succeed, strengthening self-efficacy
                    over time.</p>
          </article>
     </section>

     <section id="section3" class="panel">
          <article class="content">
               <h1 class="title">Act 3: Safe Failure, Real Growth</h1>
               <p class="tooltip">Safe Failure: Learning Without Real-World Consequences</p>
               <p>Failure in real life carries consequences. Games offer a <strong>safe laboratory</strong> for failure.
                    You can die hundreds of times in <em>Hollow Knight</em> without judgment or permanent loss. That
                    freedom turns failure into information, not shame.</p>
               <p>Every death teaches a lesson; every retry strengthens resolve. Over time, players cultivate a
                    <strong>growth mindset</strong>—the belief that ability can be developed through effort. In
                    difficult games, failure becomes feedback, not a verdict.
               </p>
          </article>
     </section>

     <section id="section4" class="panel">
          <article class="content">
               <h1 class="title">Act 4: “Just One More Try”</h1>
               <p class="tooltip">Persistence, Investment, and Intermittent Wins</p>
               <p>Why don’t players quit? Partly: the <strong>sunk cost fallacy</strong>. After hours of learning a
                    boss’s patterns, giving up feels like wasting the investment. Designers also lean on
                    <strong>incremental progress</strong> and <strong>intermittent reinforcement</strong>—powerful
                    motivators that make every “almost” attempt feel like progress.
               </p>
               <p>Crucially, rewards here aren’t random—success is earned through skill. That’s why the payoff is
                    profoundly satisfying rather than exploitative.</p>
          </article>
     </section>

     <section id="section5" class="panel">
          <article class="content">
               <h1 class="title">Act 5: Difficulty as a Badge of Honor</h1>
               <p class="tooltip">The Social Side of Struggle</p>
               <p>In today’s gaming culture, difficulty becomes <strong>social capital</strong>. Beating <em>Sekiro</em>
                    or speed-running <em>Celeste</em> isn’t just personal—it’s performative. Twitch, YouTube, and Reddit
                    turn struggle into story, and story into community.</p>
               <p>This fulfills SDT’s need for relatedness: achievement means more when it’s shared. Mutual frustration
                    and triumph create identity and belonging.</p>
          </article>
     </section>

     <section id="epilogue" class="panel">
          <article class="content">
               <h1 class="title">Epilogue: Finding Meaning in the Struggle</h1>
               <p class="tooltip">Conclusion: Finding Meaning in the Struggle</p>
               <p>Difficult games remind us that growth comes through discomfort, that mastery requires persistence, and
                    that failure is the foundation of success. They reintroduce <strong>friction as meaning</strong> in
                    an age of instant gratification.</p>
               <p>When that victory screen finally appears, the joy isn’t just digital—it’s human. Through effort,
                    patience, and resilience, we glimpse our capacity to endure, learn, and triumph.</p>
          </article>
     </section>


     <script>

          /* -------- Intro overlay -------- */
          $(function () {
               const $overlay = $("#intro-overlay");
               requestAnimationFrame(() => $overlay.addClass("in"));
               function dismissOverlay() {
                    $overlay.addClass("out");
                    setTimeout(() => $overlay.remove(), 500);
               }
               $overlay.on("click", dismissOverlay);
               $(window).on("keydown", (e) => {
                    if (e.key === "Escape" || e.key === "Enter" || e.key === " ") dismissOverlay();
               });
          });

          /* -------- Snap + Nav rail -------- */
          $(function () {
               const $win = $(window);
               const $root = $("html, body");
               const $sections = $(".panel");
               const $items = $("#nav-rail .nav-item");
               const $notches = $items.find(".notch");
               const $fill = $("#nav-rail .rail-fill");
               let tops = [];
               let index = 0;
               let animating = false;
               let wheelCooldown = false;

               function measure() {
                    tops = $sections.map(function () {
                         return Math.round($(this).offset().top);
                    }).get();
               }

               function clamp(i) {
                    return Math.max(0, Math.min(i, $sections.length - 1));
               }

               function setProgress(i) {
                    const p = ($sections.length > 1) ? (i / ($sections.length - 1)) : 0;
                    $fill.css("height", (p * 100) + "%");

                    // cumulative red for items (not just notches)
                    $items.each(function (idx) {
                         const $it = $(this);
                         $it.toggleClass("past", idx <= i);
                         $it.toggleClass("active", idx === i);
                    });
               }

               function scrollToIndex(i, duration = 500) {
                    i = clamp(i);
                    animating = true;
                    wheelCooldown = true;
                    $root.stop(true).animate(
                         { scrollTop: tops[i] },
                         duration,
                         "swing",
                         function () {
                              animating = false;
                              index = i;
                              setProgress(index);
                              setTimeout(() => (wheelCooldown = false), 120);
                         }
                    );
               }

               function nearestIndex(scrollTop) {
                    let best = 0, bestDist = Infinity;
                    for (let i = 0; i < tops.length; i++) {
                         const d = Math.abs(tops[i] - scrollTop);
                         if (d < bestDist) { bestDist = d; best = i; }
                    }
                    return best;
               }

               // Initial layout + snap to first
               measure();
               $root.scrollTop(tops[0]);
               setProgress(0);

               // When hovering a label (or the whole item), show that section's title in the hint
               $("#nav-rail").on("mouseenter", ".nav-item, .nav-item .label", function () {
                    const $item = $(this).closest(".nav-item");
                    const i = Number($item.data("i"));
                    const $sec = $sections.eq(i);
                    const text = $sec.find(".tooltip").first().text().trim();

                    const $hint = $item.find(".hint");
                    $hint.text(text || "").addClass("show");
               });

               $("#nav-rail").on("mouseleave", ".nav-item, .nav-item .label", function () {
                    $(this).closest(".nav-item").find(".hint").removeClass("show");
               });

               $items.each(function () {
                    if (!$(this).find(".hint").length) {
                         $(this).append('<div class="hint" aria-hidden="true"></div>');
                    }
               });



               // Notch + label clicks (delegate)
               $("#nav-rail").on("click", ".nav-item, .nav-item .notch, .nav-item .label", function (e) {
                    e.preventDefault();
                    const i = Number($(this).closest(".nav-item").data("i"));
                    scrollToIndex(i);
               });

               // Wheel/trackpad
               window.addEventListener("wheel", function (ev) {
                    if (animating || wheelCooldown) { ev.preventDefault(); return; }
                    const dy = ev.deltaY || ev.wheelDeltaY || ev.wheelDelta || 0;
                    if (dy === 0) return;
                    ev.preventDefault();
                    scrollToIndex(index + (dy > 0 ? 1 : -1));
               }, { passive: false });

               // Keyboard
               $(window).on("keydown", function (e) {
                    if (animating) return;
                    const nextKeys = ["ArrowDown", "PageDown", " "];
                    const prevKeys = ["ArrowUp", "PageUp"];
                    if (nextKeys.includes(e.key)) {
                         e.preventDefault();
                         scrollToIndex(index + 1);
                    } else if (prevKeys.includes(e.key)) {
                         e.preventDefault();
                         scrollToIndex(index - 1);
                    } else if (e.key === "Home") {
                         e.preventDefault();
                         scrollToIndex(0);
                    } else if (e.key === "End") {
                         e.preventDefault();
                         scrollToIndex($sections.length - 1);
                    }
               });


               // Sync index/progress if user jumps or after resize
               let scrollDebounce;
               $(window).on("scroll", function () {
                    if (animating) return;
                    clearTimeout(scrollDebounce);
                    scrollDebounce = setTimeout(() => {
                         const st = Math.round($win.scrollTop());
                         index = nearestIndex(st);
                         setProgress(index);
                    }, 80);
               });

               let resizeDebounce;
               $(window).on("resize", function () {
                    clearTimeout(resizeDebounce);
                    resizeDebounce = setTimeout(() => {
                         const currentId = $sections.eq(index).attr("id");
                         measure();
                         const i = Math.max(0, $sections.index($("#" + currentId)));
                         $root.stop(true, true).scrollTop(tops[i]);
                         index = i;
                         setProgress(index);
                    }, 100);
               });
          });


     </script>
</body>

</html>