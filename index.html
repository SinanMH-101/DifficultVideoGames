<!DOCTYPE html>
<html lang="en">

<head>
     <meta charset="UTF-8" />
     <meta name="viewport" content="width=device-width,initial-scale=1.0" />
     <link rel="stylesheet" href="styles.css" />
     <title>Difficult Videogames</title>
     <script src="https://code.jquery.com/jquery-3.7.1.min.js"
          integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
</head>

<body>

     <!--“You Died” style intro overlay -->
     <div id="intro-overlay" role="dialog" aria-modal="true" aria-label="Page title">
          <div class="intro-inner">
               <h1 class="intro-title">Difficult Videogames (WIP)</h1>
               <p class="intro-sub">click anywhere to continue</p>
          </div>
     </div>

     <!--Left progress/navigation rail (7 notches now) -->
     <nav id="nav-rail" aria-label="Page progress">
          <div class="rail">
               <div class="rail-fill" aria-hidden="true"></div>

               <!-- 7 evenly spaced notches (prologue..epilogue) -->
               <div class="nav-item" style="top:0%" data-i="0">
                    <button class="notch" aria-label="Go to Prologue"></button>
                    <span class="label">Prologue</span>
               </div>
               <div class="nav-item" style="top:16.66%" data-i="1">
                    <button class="notch" aria-label="Go to Section 1"></button>
                    <span class="label">Act 1</span>
               </div>
               <div class="nav-item" style="top:33.33%" data-i="2">
                    <button class="notch" aria-label="Go to Section 2"></button>
                    <span class="label">Act 2</span>
               </div>
               <div class="nav-item" style="top:50%" data-i="3">
                    <button class="notch" aria-label="Go to Section 3"></button>
                    <span class="label">Act 3</span>
               </div>
               <div class="nav-item" style="top:66.66%" data-i="4">
                    <button class="notch" aria-label="Go to Section 4"></button>
                    <span class="label">Act 4</span>
               </div>
               <div class="nav-item" style="top:83.33%" data-i="5">
                    <button class="notch" aria-label="Go to Section 5"></button>
                    <span class="label">Act 5</span>
               </div>
               <div class="nav-item" style="top:100%" data-i="6">
                    <button class="notch" aria-label="Go to Epilogue"></button>
                    <span class="label">Epilogue</span>
               </div>
          </div>
     </nav>

     <!-- Sections -->
     <section id="prologue" class="panel">

          <article class="content">
               <h1 class="title">Prologue: Why We Love to Suffer (Digitally)</h1>
               <p class="tooltip"> Why We Love to Suffer (Digitally) </p>
               <p>From <em>Dark Souls</em> and <em>Sekiro</em> to <em>Cuphead</em> and <em>Getting Over It with Bennett
                         Foddy</em>, modern gaming has embraced a new breed of challenge—one that seems almost designed
                    to test the limits of our patience. These are games that punish mistakes, offer little mercy, and
                    proudly display your failures with every “You Died” screen. Yet despite the rage and frustration,
                    players flock to them, replaying boss fights hundreds of times and celebrating even the smallest
                    victories.</p>
               <p>Why do we voluntarily endure such torment—and even enjoy it? The answer lies not in masochism, but in
                    psychology. Difficult games offer something deeper than surface-level fun: they satisfy primal human
                    needs for mastery, growth, and meaning. They transform frustration into fulfillment, making players
                    feel alive in ways few other activities can.</p>
          </article>
     </section>

     <section id="section1" class="panel">
          <article class="content">
               <h1 class="title">Act 1: The Challenge–Skill Balance — Flow in the Face of Frustration</h1>
               <p class="tooltip">Flow in the Face of Frustration</p>

               <p>At first glance, difficulty and enjoyment seem incompatible. How can failing repeatedly be fun?
                    Cognitive psychology provides the answer through Mihaly Csikszentmihalyi’s concept of
                    <strong>flow</strong>—a mental state of deep, focused immersion that occurs when the challenge of a
                    task perfectly matches the individual’s skill level.</p>

               <p>When games are too easy, we get bored. When they’re too hard, we feel anxious or helpless. But when a
                    game strikes that delicate balance—demanding constant focus while still feeling achievable—it
                    creates flow. Time fades away, and every small success feels electric. This is why players can spend
                    hours replaying the same section in <em>Elden Ring</em> or <em>Celeste</em>: the game continually
                    pushes them to learn, adapt, and refine their skills.</p>

               <p>Frustration becomes part of the pleasure because it gives meaning to success. When victory finally
                    arrives, it isn’t luck—it’s earned. The struggle is the story. Players come away not only with a
                    sense of relief but with pride, knowing that they’ve overcome something legitimately difficult. In
                    that sense, the pain of repeated failure amplifies the joy of success, turning the experience into
                    something deeply satisfying and memorable.</p>
          </article>
     </section>

     <section id="section2" class="panel">
          <article class="content">
               <h1 class="title">Act 2: Mastery and the Reward of Competence — The Drive to Improve</h1>
               <p class="tooltip">Mastery & Competence</p>

               <p>According to Self-Determination Theory (SDT), human motivation is powered by three intrinsic
                    psychological needs: autonomy (the need to choose), relatedness (the need to connect), and
                    competence (the need to improve and master challenges). Difficult games speak directly to that third
                    need—competence.</p>

               <p>When you finally defeat a tough boss in <em>Dark Souls</em>, the game doesn’t just progress—it proves
                    something. It validates the hours spent learning patterns, timing dodges, and adjusting strategies.
                    This mastery produces a neurological reward: a burst of dopamine, the brain’s chemical of motivation
                    and pleasure. Unlike the instant gratification of easy games, this reward feels hard-earned,
                    authentic, and lasting.</p>

               <p>That’s why players often describe difficult games as fair. Even when they lose, they recognize that
                    the failure was theirs to own—and that the victory will be too. It’s a rare example of pure
                    meritocracy: skill, effort, and persistence are the only paths forward. In a world where so many
                    outcomes feel beyond our control, that sense of fairness and agency is incredibly empowering.</p>

               <p>This loop of challenge and reward forms a powerful motivational cycle. The player fails, learns,
                    improves, and succeeds—only to seek out the next challenge. Each cycle strengthens self-efficacy:
                    the belief in one’s own ability to overcome obstacles. Over time, this psychological reward can
                    become more compelling than the game’s actual narrative.</p>
          </article>
     </section>

     <section id="section3" class="panel">
          <article class="content">
               <h1 class="title">Act 3: Safe Failure — Learning Without Real-World Consequences</h1>
               <p class="tooltip">Safe Failure</p>

               <p>Failure in real life carries consequences—lost money, social embarrassment, damaged confidence. Games,
                    by contrast, offer a safe laboratory for failure. You can die hundreds of times in <em>Hollow
                         Knight</em> without judgment or permanent loss. That freedom creates a rare space where failure
                    becomes informative rather than shameful.</p>

               <p>Psychologists describe games as “failure simulators”—controlled environments where we can experiment,
                    fail, and adapt without real-world stakes. In this sense, difficult games function like resilience
                    training. Every death teaches a lesson, every retry strengthens resolve, and every setback becomes
                    data. The player learns to detach emotion from outcome, analyzing what went wrong and adjusting
                    accordingly.</p>

               <p>Over time, this process cultivates what psychologist Carol Dweck calls a <strong>growth
                         mindset</strong>—the belief that ability can be developed through effort. Players learn that
                    frustration isn’t a dead end but a sign of progress. When applied beyond gaming, this mindset
                    translates to real-world perseverance: the student who keeps studying after a bad grade or the
                    athlete who practices after a loss is following the same psychological pattern that gamers learn in
                    virtual worlds.</p>

               <p>Failure, then, becomes a form of play. In difficult games, it’s not something to avoid but to engage
                    with. It transforms from punishment into feedback, turning every defeat into another step toward
                    mastery.</p>
          </article>
     </section>

     <section id="section4" class="panel">
          <article class="content">
               <h1 class="title">Act 4: Persistence & Investment — The Psychology of “Just One More Try”</h1>
               <p class="tooltip">“Just One More Try”</p>

               <p>If difficult games are so punishing, why don’t players quit? Part of the answer lies in behavioral
                    economics—specifically, the <strong>sunk cost fallacy</strong>. This is the tendency to continue
                    investing time and effort in something because of what’s already been invested, even when quitting
                    might make rational sense.</p>

               <p>In gaming, the sunk cost fallacy can keep players hooked. After spending hours studying a boss’s
                    attack patterns, the idea of giving up feels like wasting all that effort. Developers know this and
                    often design incremental progress systems—tiny wins, unlockable rewards, or narrative payoffs—to
                    keep players motivated. Each “almost” moment plants the seed of persistence: next time, I’ll get it.
               </p>

               <p>This mechanism resembles <strong>intermittent reinforcement</strong>—a psychological phenomenon where
                    unpredictable rewards create stronger habits. It’s the same principle behind slot machines, but in
                    difficult games, the reward isn’t luck—it’s earned through skill. That difference makes the outcome
                    deeply satisfying rather than exploitative.</p>

               <p>In fact, this psychological rhythm—try, fail, improve, succeed—is one of the most compelling loops in
                    game design. It mirrors how humans learn in general. Each attempt feels like progress, even if it
                    ends in failure, because the effort itself builds competence and anticipation. When victory finally
                    arrives, the emotional payoff is massive precisely because it was unpredictable and hard-won.</p>
          </article>
     </section>

     <section id="section5" class="panel">
          <article class="content">
               <h1 class="title">Act 5: The Social Side of Struggle — Difficulty as a Badge of Honor</h1>
               <p class="tooltip">Difficulty as a Badge of Honor</p>

               <p>In today’s interconnected gaming culture, difficulty doesn’t exist in isolation. Beating
                    <em>Sekiro</em> or speed-running <em>Celeste</em> is not just a personal victory—it’s a social
                    statement. Platforms like Twitch, YouTube, and Reddit have turned difficult games into stages for
                    performance, storytelling, and community.</p>

               <p>Sharing war stories about brutal bosses or impossible levels fosters a sense of belonging. Watching
                    others struggle and succeed creates empathy and admiration. Completing a no-death run or achieving a
                    world record speed-run becomes a form of social capital—proof of dedication and skill.</p>

               <p>This fulfills the third core need in Self-Determination Theory: <strong>relatedness</strong>. Humans
                    are social creatures, and accomplishment means more when it’s shared. Difficult games, by design,
                    generate narratives worth telling. The experience of mutual struggle—whether watching a streamer
                    overcome Maliketh or posting your own triumph online—builds identity and camaraderie.</p>

               <p>In this way, difficulty becomes communal. It’s not just you against the game; it’s you alongside
                    countless others, all united by shared frustration and triumph. Each victory adds to the collective
                    mythology of gaming—a culture built on endurance, pride, and respect.</p>
          </article>
     </section>

     <section id="epilogue" class="panel">
          <article class="content">
               <h1 class="title">Epilogue: Finding Meaning in the Struggle</h1>
               <p class="tooltip">Finding Meaning in the Struggle</p>

               <p>The enduring appeal of difficult video games reveals something profound about human nature. They
                    remind us that growth often comes through discomfort, that mastery requires persistence, and that
                    failure is not the opposite of success but its foundation.</p>

               <p>Games like <em>Dark Souls</em> or <em>Sekiro</em> don’t coddle us—they challenge us to rise. They
                    strip away shortcuts and force us to confront our limitations head-on. Every death teaches patience;
                    every retry builds determination. The result is not just entertainment but transformation.</p>

               <p>In an age of instant gratification, where most apps and algorithms are designed to remove friction,
                    difficult games stand apart. They reintroduce friction as meaning. They prove that struggle can be
                    beautiful—that our enjoyment deepens when it’s earned.</p>

               <p>When you finally defeat that impossible boss after fifty attempts, the joy you feel isn’t just
                    digital—it’s human. It’s the same joy that comes from finishing a marathon, learning a new skill, or
                    overcoming hardship. These games tap into an ancient truth: we are built not to avoid struggle, but
                    to grow through it.</p>

               <p>So, the next time you throw your controller in frustration, remember: you’re not just playing a
                    game—you’re participating in one of humanity’s oldest rituals. Through effort, patience, and
                    resilience, you’re proving to yourself that mastery is possible. And when that long-awaited victory
                    screen finally appears, what you’ve earned isn’t just a win—it’s a glimpse into your own capacity to
                    endure, to learn, and to triumph.</p>
          </article>
     </section>
     </section>


     <script>

          /* -------- Intro overlay -------- */
          $(function () {
               const $overlay = $("#intro-overlay");
               requestAnimationFrame(() => $overlay.addClass("in"));
               function dismissOverlay() {
                    $overlay.addClass("out");
                    setTimeout(() => $overlay.remove(), 500);
               }
               $overlay.on("click", dismissOverlay);
               $(window).on("keydown", (e) => {
                    if (e.key === "Escape" || e.key === "Enter" || e.key === " ") dismissOverlay();
               });
          });

          /* -------- Snap + Nav rail -------- */
          $(function () {
               const $win = $(window);
               const $root = $("html, body");
               const $sections = $(".panel");
               const $items = $("#nav-rail .nav-item");
               const $notches = $items.find(".notch");
               const $fill = $("#nav-rail .rail-fill");
               let tops = [];
               let index = 0;
               let animating = false;
               let wheelCooldown = false;

               function measure() {
                    tops = $sections.map(function () {
                         return Math.round($(this).offset().top);
                    }).get();
               }

               function clamp(i) {
                    return Math.max(0, Math.min(i, $sections.length - 1));
               }

               function setProgress(i) {
                    const p = ($sections.length > 1) ? (i / ($sections.length - 1)) : 0;
                    $fill.css("height", (p * 100) + "%");

                    // cumulative red for items (not just notches)
                    $items.each(function (idx) {
                         const $it = $(this);
                         $it.toggleClass("past", idx <= i);
                         $it.toggleClass("active", idx === i);
                    });
               }

               function scrollToIndex(i, duration = 500) {
                    i = clamp(i);
                    animating = true;
                    wheelCooldown = true;
                    $root.stop(true).animate(
                         { scrollTop: tops[i] },
                         duration,
                         "swing",
                         function () {
                              animating = false;
                              index = i;
                              setProgress(index);
                              setTimeout(() => (wheelCooldown = false), 120);
                         }
                    );
               }

               function nearestIndex(scrollTop) {
                    let best = 0, bestDist = Infinity;
                    for (let i = 0; i < tops.length; i++) {
                         const d = Math.abs(tops[i] - scrollTop);
                         if (d < bestDist) { bestDist = d; best = i; }
                    }
                    return best;
               }

               // Initial layout + snap to first
               measure();
               $root.scrollTop(tops[0]);
               setProgress(0);

               // When hovering a label (or the whole item), show that section's title in the hint
               $("#nav-rail").on("mouseenter", ".nav-item, .nav-item .label", function () {
                    const $item = $(this).closest(".nav-item");
                    const i = Number($item.data("i"));
                    const $sec = $sections.eq(i);
                    const text = $sec.find(".tooltip").first().text().trim();

                    const $hint = $item.find(".hint");
                    $hint.text(text || "").addClass("show");
               });

               $("#nav-rail").on("mouseleave", ".nav-item, .nav-item .label", function () {
                    $(this).closest(".nav-item").find(".hint").removeClass("show");
               });

               $items.each(function () {
                    if (!$(this).find(".hint").length) {
                         $(this).append('<div class="hint" aria-hidden="true"></div>');
                    }
               });



               // Notch + label clicks (delegate)
               $("#nav-rail").on("click", ".nav-item, .nav-item .notch, .nav-item .label", function (e) {
                    e.preventDefault();
                    const i = Number($(this).closest(".nav-item").data("i"));
                    scrollToIndex(i);
               });

               // Wheel/trackpad
               window.addEventListener("wheel", function (ev) {
                    if (animating || wheelCooldown) { ev.preventDefault(); return; }
                    const dy = ev.deltaY || ev.wheelDeltaY || ev.wheelDelta || 0;
                    if (dy === 0) return;
                    ev.preventDefault();
                    scrollToIndex(index + (dy > 0 ? 1 : -1));
               }, { passive: false });

               // Keyboard
               $(window).on("keydown", function (e) {
                    if (animating) return;
                    const nextKeys = ["ArrowDown", "PageDown", " "];
                    const prevKeys = ["ArrowUp", "PageUp"];
                    if (nextKeys.includes(e.key)) {
                         e.preventDefault();
                         scrollToIndex(index + 1);
                    } else if (prevKeys.includes(e.key)) {
                         e.preventDefault();
                         scrollToIndex(index - 1);
                    } else if (e.key === "Home") {
                         e.preventDefault();
                         scrollToIndex(0);
                    } else if (e.key === "End") {
                         e.preventDefault();
                         scrollToIndex($sections.length - 1);
                    }
               });


               // Sync index/progress if user jumps or after resize
               let scrollDebounce;
               $(window).on("scroll", function () {
                    if (animating) return;
                    clearTimeout(scrollDebounce);
                    scrollDebounce = setTimeout(() => {
                         const st = Math.round($win.scrollTop());
                         index = nearestIndex(st);
                         setProgress(index);
                    }, 80);
               });

               let resizeDebounce;
               $(window).on("resize", function () {
                    clearTimeout(resizeDebounce);
                    resizeDebounce = setTimeout(() => {
                         const currentId = $sections.eq(index).attr("id");
                         measure();
                         const i = Math.max(0, $sections.index($("#" + currentId)));
                         $root.stop(true, true).scrollTop(tops[i]);
                         index = i;
                         setProgress(index);
                    }, 100);
               });
          });


     </script>
</body>

</html>